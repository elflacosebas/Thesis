
dataIn <- read.table("https://raw.githubusercontent.com/elflacosebas/thesis/master/mexico.txt",header = T)

require(nloptr)

exp.test <-function(x1,a1,alpha1,a2,mu2,alpha2,lambda2,a3,mu3,alpha3,lambda3,c1){
  x <- x1
  exp1 <- (a1 * exp(-alpha1 * x)) + (a2 * exp(-alpha2 * (x-mu2) - exp(-lambda2 * (x - mu2)))) + (a3 * exp(-alpha3 * (x-mu3) - exp(-lambda3 * (x - mu3)))) + c1
  
  return(exp1)
}
############################################
#
# 
################################################################## 
rc.11 <- expression(log((a1 * exp(-alpha1 * x)) + (a2 * exp(-alpha2 * (x-mu2) - exp(-lambda2 * (x - mu2)))) + (a3 * exp(-alpha3 * (x-mu3) - exp(-lambda3 * (x - mu3)))) + c1))

sapply(all.vars(rc.11), function(v){
  D(rc.11, v)
})


genRandomPar <- function()  {      
  
  #primera exponencial
  a1 <- runif(1,0.01,0.08)
  alpha1 <- runif(1,0,1)
  
  #segunda exponencial
  a2 <- runif(1,0.01 ,0.08)
  alpha2 <- runif(1,0,1)
  mu2 <- runif(1,15,30)
  lambda2 <- runif(1,0,1)
  
  #tercera exponencial
  a3 <- runif(1,0,1)
  alpha3 <- runif(1,0,1)
  mu3 <- runif(1,75,85)
  lambda3 <- runif(1,0,1)
  
  #constante
  c1 <- runif(1,0.01,0.05)
  parameters_0 <- c(a1=a1,alpha1=alpha1,a2=a2,mu2=mu2,alpha2=alpha2,lambda2=lambda2,a3=a3,mu3=mu3,alpha3=alpha3
                    ,lambda3=lambda3,c1=c1)
  
  return(parameters_0)
}

x <- 1:100
J <-  t(sapply(names(parameters_0), function(v, env){
  eval(D(rc.11, v), env)
}, env=c(as.list(parameters_0), list(x=x))))

# and then a gradient vector
r <- runif(length(x))
gr <-  -J %*% r

# and then an approximate Hessian matrix
H <-  J %*% t(J)

nlminb(parameters_0 , function(p, data){
  r = data$proportion - eval(rc.11)
  return(r %*% r)
}, gradient = gr, hessian = H, data=dataIn)



ModelObject <- setRefClass('ModelObject', 
                           fields = list(
                             name = 'character',
                             expr = 'expression'
                           ),
                           methods = list(
                             value = function(p, data){
                               eval(.self$expr, c(as.list(p), as.list(data)))
                             },
                             jacobian = function(p, data){
                               J = t(sapply(all.vars(.self$expr), function(v, p, data){
                                 # if(v != "c1"){
                                 eval(D(.self$expr, v), c(as.list(p), as.list(data)))
                                 # } else { rep(1, nrow(data))}
                               }, p=p, data=data))
                               
                               return(J[names(p),,drop=F])
                             },
                             gradient = function(p, data){
                               r = data$y - value(p, data)
                               return(-jacobian(p, data) %*% r)
                             },
                             hessian = function(p, data){
                               J = jacobian(p, data)
                               return(J %*% t(J))
                             }
                           )
)


parameters_0 <- genRandomPar()
mo = ModelObject(
  name = 'castro_11', 
  expr = rc.11
)

valSim <- NA
plot(dataIn, cex=0.2)
for(i in 1:5000){
  parameters_0 <-  genRandomPar()
  graProof <- mo$gradient(p= parameters_0, data = dataIn)
  while((any(is.na(graProof)) & any(is.nan(graProof)))){
    parameters_0 <-  genRandomPar()
    graProof <- mo$gradient(p= parameters_0, data = dataIn)
  }
  
  fit1 <-  nlminb(parameters_0 , function(p, data){
    r = data$y - mo$value(p,data)
    return(r %*% r)
  }, gradient = mo$gradient, hessian = mo$hessian, data=dataIn)
  
  lines(dataIn$x, mo$value(fit1$par,dataIn), col="blue")
  valSim <- rbind(valSim,c(parameters_0, fit1$par, fit1$objective, fit1$message))
}


